"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = placeCaretAtHorizontalEdge;

var _assertIsDefined = require("../utils/assert-is-defined");

var _hiddenCaretRangeFromPoint = _interopRequireDefault(require("./hidden-caret-range-from-point"));

var _isInputOrTextArea = _interopRequireDefault(require("./is-input-or-text-area"));

/**
 * Internal dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Places the caret at start or end of a given element.
 *
 * @param {HTMLElement} container    Focusable element.
 * @param {boolean} isReverse    True for end, false for start.
 * @param {boolean} [mayUseScroll=false] Whether to allow scrolling.
 */
function placeCaretAtHorizontalEdge(container, isReverse) {
  var mayUseScroll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!container) {
    return;
  }

  container.focus();

  if ((0, _isInputOrTextArea.default)(container)) {
    // The element may not support selection setting.
    if (typeof container.selectionStart !== 'number') {
      return;
    }

    if (isReverse) {
      container.selectionStart = container.value.length;
      container.selectionEnd = container.value.length;
    } else {
      container.selectionStart = 0;
      container.selectionEnd = 0;
    }

    return;
  }

  if (!container.isContentEditable) {
    return;
  }

  var ownerDocument = container.ownerDocument;
  var containerRect = container.getBoundingClientRect(); // When placing at the end (isReverse), find the closest range to the bottom
  // right corner. When placing at the start, to the top left corner.

  var x = isReverse ? containerRect.right - 1 : containerRect.left + 1;
  var y = isReverse ? containerRect.bottom - 1 : containerRect.top + 1;
  var range = (0, _hiddenCaretRangeFromPoint.default)(ownerDocument, x, y, container); // If no range range can be created or it is outside the container, the
  // element may be out of view.

  if (!range || !range.startContainer || !container.contains(range.startContainer)) {
    if (!mayUseScroll) {
      return;
    } // Only try to scroll into view once to avoid an infinite loop.


    mayUseScroll = false;
    container.scrollIntoView(isReverse);
    placeCaretAtHorizontalEdge(container, isReverse, mayUseScroll);
    return;
  }

  var defaultView = ownerDocument.defaultView;
  (0, _assertIsDefined.assertIsDefined)(defaultView, 'defaultView');
  var selection = defaultView.getSelection();
  (0, _assertIsDefined.assertIsDefined)(selection, 'selection');
  selection.removeAllRanges();
  selection.addRange(range);
}
//# sourceMappingURL=place-caret-at-horizontal-edge.js.map
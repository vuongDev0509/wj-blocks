/**
 * External dependencies
 */
import { includes, noop } from 'lodash';
/**
 * Internal dependencies
 */

import isEmpty from './is-empty';
import remove from './remove';
import unwrap from './unwrap';
import { isPhrasingContent } from '../phrasing-content';
import insertAfter from './insert-after';
import isElement from './is-element';
/* eslint-disable jsdoc/valid-types */

/**
 * @typedef SchemaItem
 * @property {string[]} [attributes] Attributes.
 * @property {(string | RegExp)[]} [classes] Classnames or RegExp to test against.
 * @property {'*' | { [tag: string]: SchemaItem }} [children] Child schemas.
 * @property {string[]} [require] Selectors to test required children against. Leave empty or undefined if there are no requirements.
 * @property {boolean} allowEmpty Whether to allow nodes without children.
 * @property {(node: Node) => boolean} [isMatch] Function to test whether a node is a match. If left undefined any node will be assumed to match.
 */

/** @typedef {{ [tag: string]: SchemaItem }} Schema */

/* eslint-enable jsdoc/valid-types */

/**
 * Given a schema, unwraps or removes nodes, attributes and classes on a node
 * list.
 *
 * @param {NodeList} nodeList The nodeList to filter.
 * @param {Document} doc      The document of the nodeList.
 * @param {Schema}   schema   An array of functions that can mutate with the provided node.
 * @param {boolean}  inline   Whether to clean for inline mode.
 */

export default function cleanNodeList(nodeList, doc, schema, inline) {
  Array.from(nodeList).forEach(function (
  /** @type {Node & { nextElementSibling?: unknown }} */
  node) {
    var _schema$tag$isMatch, _schema$tag;

    var tag = node.nodeName.toLowerCase(); // It's a valid child, if the tag exists in the schema without an isMatch
    // function, or with an isMatch function that matches the node.

    if (schema.hasOwnProperty(tag) && (!schema[tag].isMatch || (_schema$tag$isMatch = (_schema$tag = schema[tag]).isMatch) !== null && _schema$tag$isMatch !== void 0 && _schema$tag$isMatch.call(_schema$tag, node))) {
      if (isElement(node)) {
        var _schema$tag2 = schema[tag],
            _schema$tag2$attribut = _schema$tag2.attributes,
            attributes = _schema$tag2$attribut === void 0 ? [] : _schema$tag2$attribut,
            _schema$tag2$classes = _schema$tag2.classes,
            classes = _schema$tag2$classes === void 0 ? [] : _schema$tag2$classes,
            children = _schema$tag2.children,
            _schema$tag2$require = _schema$tag2.require,
            require = _schema$tag2$require === void 0 ? [] : _schema$tag2$require,
            allowEmpty = _schema$tag2.allowEmpty; // If the node is empty and it's supposed to have children,
        // remove the node.


        if (children && !allowEmpty && isEmpty(node)) {
          remove(node);
          return;
        }

        if (node.hasAttributes()) {
          // Strip invalid attributes.
          Array.from(node.attributes).forEach(function (_ref) {
            var name = _ref.name;

            if (name !== 'class' && !includes(attributes, name)) {
              node.removeAttribute(name);
            }
          }); // Strip invalid classes.
          // In jsdom-jscore, 'node.classList' can be undefined.
          // TODO: Explore patching this in jsdom-jscore.

          if (node.classList && node.classList.length) {
            var mattchers = classes.map(function (item) {
              if (typeof item === 'string') {
                return function (
                /** @type {string} */
                className) {
                  return className === item;
                };
              } else if (item instanceof RegExp) {
                return function (
                /** @type {string} */
                className) {
                  return item.test(className);
                };
              }

              return noop;
            });
            Array.from(node.classList).forEach(function (name) {
              if (!mattchers.some(function (isMatch) {
                return isMatch(name);
              })) {
                node.classList.remove(name);
              }
            });

            if (!node.classList.length) {
              node.removeAttribute('class');
            }
          }
        }

        if (node.hasChildNodes()) {
          // Do not filter any content.
          if (children === '*') {
            return;
          } // Continue if the node is supposed to have children.


          if (children) {
            // If a parent requires certain children, but it does
            // not have them, drop the parent and continue.
            if (require.length && !node.querySelector(require.join(','))) {
              cleanNodeList(node.childNodes, doc, schema, inline);
              unwrap(node); // If the node is at the top, phrasing content, and
              // contains children that are block content, unwrap
              // the node because it is invalid.
            } else if (node.parentNode && node.parentNode.nodeName === 'BODY' && isPhrasingContent(node)) {
              cleanNodeList(node.childNodes, doc, schema, inline);

              if (Array.from(node.childNodes).some(function (child) {
                return !isPhrasingContent(child);
              })) {
                unwrap(node);
              }
            } else {
              cleanNodeList(node.childNodes, doc, children, inline);
            } // Remove children if the node is not supposed to have any.

          } else {
            while (node.firstChild) {
              remove(node.firstChild);
            }
          }
        }
      } // Invalid child. Continue with schema at the same place and unwrap.

    } else {
      cleanNodeList(node.childNodes, doc, schema, inline); // For inline mode, insert a line break when unwrapping nodes that
      // are not phrasing content.

      if (inline && !isPhrasingContent(node) && node.nextElementSibling) {
        insertAfter(doc.createElement('br'), node);
      }

      unwrap(node);
    }
  });
}
//# sourceMappingURL=clean-node-list.js.map
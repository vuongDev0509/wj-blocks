import _extends from "@babel/runtime/helpers/esm/extends";
import { createElement, Fragment } from "@wordpress/element";
// @ts-nocheck

/**
 * WordPress dependencies
 */
import { isRTL } from '@wordpress/i18n';
/**
 * Internal dependencies
 */

import RangeMark from './mark';
import { MarksWrapper, Rail } from './styles/range-control-styles';
export default function RangeRail(_ref) {
  let {
    disabled = false,
    marks = false,
    min = 0,
    max = 100,
    step = 1,
    value = 0,
    ...restProps
  } = _ref;
  return createElement(Fragment, null, createElement(Rail, _extends({
    disabled: disabled
  }, restProps)), marks && createElement(Marks, {
    disabled: disabled,
    marks: marks,
    min: min,
    max: max,
    step: step,
    value: value
  }));
}

function Marks(_ref2) {
  let {
    disabled = false,
    marks = false,
    min = 0,
    max = 100,
    step = 1,
    value = 0
  } = _ref2;

  if (step === 'any') {
    step = 1;
  }

  const marksData = useMarks({
    marks,
    min,
    max,
    step,
    value
  });
  return createElement(MarksWrapper, {
    "aria-hidden": "true",
    className: "components-range-control__marks"
  }, marksData.map(mark => createElement(RangeMark, _extends({}, mark, {
    key: mark.key,
    "aria-hidden": "true",
    disabled: disabled
  }))));
}

function useMarks(_ref3) {
  let {
    marks,
    min = 0,
    max = 100,
    step = 1,
    value = 0
  } = _ref3;

  if (!marks) {
    return [];
  }

  const range = max - min;

  if (!Array.isArray(marks)) {
    marks = [];
    const count = 1 + Math.round(range / step);

    while (count > marks.push({
      value: step * marks.length + min
    }));
  }

  const placedMarks = [];
  marks.forEach((mark, index) => {
    if (mark.value < min || mark.value > max) {
      return;
    }

    const key = `mark-${index}`;
    const isFilled = mark.value <= value;
    const offset = `${(mark.value - min) / range * 100}%`;
    const offsetStyle = {
      [isRTL() ? 'right' : 'left']: offset
    };
    placedMarks.push({ ...mark,
      isFilled,
      key,
      style: offsetStyle
    });
  });
  return placedMarks;
}
//# sourceMappingURL=rail.js.map
/**
 * WordPress dependencies
 */
import { useCallback, useMemo, useState } from '@wordpress/element';
/**
 * Internal dependencies
 */

import * as styles from '../styles';
import { parseQuantityAndUnitFromRawValue } from '../../unit-control/utils';
import { useContextSystem } from '../../ui/context';
import { useCx } from '../../utils/hooks/use-cx';

const sanitizeBorder = border => {
  const hasNoWidth = (border === null || border === void 0 ? void 0 : border.width) === undefined || border.width === '';
  const hasNoColor = (border === null || border === void 0 ? void 0 : border.color) === undefined; // If width and color are undefined, unset any style selection as well.

  if (hasNoWidth && hasNoColor) {
    return undefined;
  }

  return border;
};

export function useBorderControl(props) {
  const {
    className,
    isCompact,
    onChange,
    shouldSanitizeBorder = true,
    value: border,
    width,
    ...otherProps
  } = useContextSystem(props, 'BorderControl');
  const [widthValue, originalWidthUnit] = parseQuantityAndUnitFromRawValue(border === null || border === void 0 ? void 0 : border.width);
  const widthUnit = originalWidthUnit || 'px';
  const hadPreviousZeroWidth = widthValue === 0;
  const [colorSelection, setColorSelection] = useState();
  const [styleSelection, setStyleSelection] = useState();
  const onBorderChange = useCallback(newBorder => {
    if (shouldSanitizeBorder) {
      return onChange(sanitizeBorder(newBorder));
    }

    onChange(newBorder);
  }, [onChange, shouldSanitizeBorder, sanitizeBorder]);
  const onWidthChange = useCallback(newWidth => {
    const newWidthValue = newWidth === '' ? undefined : newWidth;
    const [parsedValue] = parseQuantityAndUnitFromRawValue(newWidth);
    const hasZeroWidth = parsedValue === 0;
    const updatedBorder = { ...border,
      width: newWidthValue
    }; // Setting the border width explicitly to zero will also set the
    // border style to `none` and clear the border color.

    if (hasZeroWidth && !hadPreviousZeroWidth) {
      // Before clearing the color and style selections, keep track of
      // the current selections so they can be restored when the width
      // changes to a non-zero value.
      setColorSelection(border === null || border === void 0 ? void 0 : border.color);
      setStyleSelection(border === null || border === void 0 ? void 0 : border.style); // Clear the color and style border properties.

      updatedBorder.color = undefined;
      updatedBorder.style = 'none';
    } // Selection has changed from zero border width to non-zero width.


    if (!hasZeroWidth && hadPreviousZeroWidth) {
      // Restore previous border color and style selections if width
      // is now not zero.
      if (updatedBorder.color === undefined) {
        updatedBorder.color = colorSelection;
      }

      if (updatedBorder.style === 'none') {
        updatedBorder.style = styleSelection;
      }
    }

    onBorderChange(updatedBorder);
  }, [border, hadPreviousZeroWidth, onBorderChange]);
  const onSliderChange = useCallback(value => {
    onWidthChange(`${value}${widthUnit}`);
  }, [onWidthChange, widthUnit]); // Generate class names.

  const cx = useCx();
  const classes = useMemo(() => {
    return cx(styles.borderControl, className);
  }, [className, cx]);
  const innerWrapperClassName = useMemo(() => {
    const wrapperWidth = isCompact ? '90px' : width;
    const widthStyle = !!wrapperWidth && styles.wrapperWidth(wrapperWidth);
    return cx(styles.innerWrapper(), widthStyle);
  }, [isCompact, width, cx]);
  const widthControlClassName = useMemo(() => {
    return cx(styles.borderWidthControl());
  }, [cx]);
  const sliderClassName = useMemo(() => {
    return cx(styles.borderSlider());
  }, [cx]);
  return { ...otherProps,
    className: classes,
    innerWrapperClassName,
    onBorderChange,
    onSliderChange,
    onWidthChange,
    previousStyleSelection: styleSelection,
    sliderClassName,
    value: border,
    widthControlClassName,
    widthUnit,
    widthValue
  };
}
//# sourceMappingURL=hook.js.map
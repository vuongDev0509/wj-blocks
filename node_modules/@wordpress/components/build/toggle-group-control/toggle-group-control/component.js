"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _reakit = require("reakit");

var _reactResizeAware = _interopRequireDefault(require("react-resize-aware"));

var _compose = require("@wordpress/compose");

var _context = require("../../ui/context");

var _hooks = require("../../utils/hooks");

var _view = require("../../view");

var _baseControl = _interopRequireDefault(require("../../base-control"));

var _toggleGroupControlBackdrop = _interopRequireDefault(require("./toggle-group-control-backdrop"));

var _context2 = _interopRequireDefault(require("../context"));

var styles = _interopRequireWildcard(require("./styles"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * External dependencies
 */
// eslint-disable-next-line no-restricted-imports

/**
 * Internal dependencies
 */
const noop = () => {};

function ToggleGroupControl(props, forwardedRef) {
  const {
    className,
    isAdaptiveWidth = false,
    isBlock = false,
    label,
    hideLabelFromVision = false,
    help,
    onChange = noop,
    value,
    children,
    ...otherProps
  } = (0, _context.useContextSystem)(props, 'ToggleGroupControl');
  const cx = (0, _hooks.useCx)();
  const containerRef = (0, _element.useRef)();
  const [resizeListener, sizes] = (0, _reactResizeAware.default)();
  const baseId = (0, _compose.useInstanceId)(ToggleGroupControl, 'toggle-group-control').toString();
  const radio = (0, _reakit.useRadioState)({
    baseId,
    state: value
  });
  const previousValue = (0, _compose.usePrevious)(value); // Propagate radio.state change.

  (0, _hooks.useUpdateEffect)(() => {
    // Avoid calling onChange if radio state changed
    // from incoming value.
    if (previousValue !== radio.state) {
      onChange(radio.state);
    }
  }, [radio.state]); // Sync incoming value with radio.state.

  (0, _hooks.useUpdateEffect)(() => {
    if (value !== radio.state) {
      radio.setState(value);
    }
  }, [value]);
  const classes = (0, _element.useMemo)(() => cx(styles.ToggleGroupControl, isBlock && styles.block, 'medium', className), [className, cx, isBlock]);
  return (0, _element.createElement)(_baseControl.default, {
    help: help
  }, (0, _element.createElement)(_context2.default.Provider, {
    value: { ...radio,
      isBlock: !isAdaptiveWidth
    }
  }, !hideLabelFromVision && (0, _element.createElement)("div", null, (0, _element.createElement)(_baseControl.default.VisualLabel, null, label)), (0, _element.createElement)(_reakit.RadioGroup, (0, _extends2.default)({}, radio, {
    "aria-label": label,
    as: _view.View,
    className: classes
  }, otherProps, {
    ref: (0, _compose.useMergeRefs)([containerRef, forwardedRef])
  }), resizeListener, (0, _element.createElement)(_toggleGroupControlBackdrop.default, (0, _extends2.default)({}, radio, {
    containerRef: containerRef,
    containerWidth: sizes.width,
    isAdaptiveWidth: isAdaptiveWidth
  })), children)));
}
/**
 * `ToggleGroupControl` is a form component that lets users choose options
 * represented in horizontal segments. To render options for this control use
 * `ToggleGroupControlOption` component.
 *
 * Only use this control when you know for sure the labels of items inside won't
 * wrap. For items with longer labels, you can consider a `SelectControl` or a
 * `CustomSelectControl` component instead.
 *
 * @example
 * ```jsx
 * import {
 *   __experimentalToggleGroupControl as ToggleGroupControl,
 *   __experimentalToggleGroupControlOption as ToggleGroupControlOption,
 * } from '@wordpress/components';
 *
 * function Example() {
 *   return (
 *     <ToggleGroupControl label="my label" value="vertical" isBlock>
 *       <ToggleGroupControlOption value="horizontal" label="Horizontal" />
 *       <ToggleGroupControlOption value="vertical" label="Vertical" />
 *     </ToggleGroupControl>
 *   );
 * }
 * ```
 */


const ConnectedToggleGroupControl = (0, _context.contextConnect)(ToggleGroupControl, 'ToggleGroupControl');
var _default = ConnectedToggleGroupControl;
exports.default = _default;
//# sourceMappingURL=component.js.map
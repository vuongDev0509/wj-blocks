"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useToolsPanelItem = useToolsPanelItem;

var _compose = require("@wordpress/compose");

var _element = require("@wordpress/element");

var styles = _interopRequireWildcard(require("../styles"));

var _context = require("../context");

var _context2 = require("../../ui/context");

var _useCx = require("../../utils/hooks/use-cx");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function useToolsPanelItem(props) {
  var _menuItems$menuGroup, _menuItems$menuGroup2;

  const {
    className,
    hasValue,
    isShownByDefault,
    label,
    panelId,
    resetAllFilter,
    onDeselect,
    onSelect,
    ...otherProps
  } = (0, _context2.useContextSystem)(props, 'ToolsPanelItem');
  const {
    panelId: currentPanelId,
    menuItems,
    registerPanelItem,
    deregisterPanelItem,
    flagItemCustomization,
    isResetting,
    shouldRenderPlaceholderItems: shouldRenderPlaceholder,
    firstDisplayedItem,
    lastDisplayedItem,
    __experimentalFirstVisibleItemClass,
    __experimentalLastVisibleItemClass
  } = (0, _context.useToolsPanelContext)();
  const hasValueCallback = (0, _element.useCallback)(hasValue, [panelId]);
  const resetAllFilterCallback = (0, _element.useCallback)(resetAllFilter, [panelId]);
  const previousPanelId = (0, _compose.usePrevious)(currentPanelId);
  const hasMatchingPanel = currentPanelId === panelId || currentPanelId === null; // Registering the panel item allows the panel to include it in its
  // automatically generated menu and determine its initial checked status.

  (0, _element.useEffect)(() => {
    if (hasMatchingPanel && previousPanelId !== null) {
      registerPanelItem({
        hasValue: hasValueCallback,
        isShownByDefault,
        label,
        resetAllFilter: resetAllFilterCallback,
        panelId
      });
    }

    return () => {
      if (previousPanelId === null && !!currentPanelId || currentPanelId === panelId) {
        deregisterPanelItem(label);
      }
    };
  }, [currentPanelId, hasMatchingPanel, isShownByDefault, label, hasValueCallback, panelId, previousPanelId, resetAllFilterCallback]);
  const isValueSet = hasValue();
  const wasValueSet = (0, _compose.usePrevious)(isValueSet); // If this item represents a default control it will need to notify the
  // panel when a custom value has been set.

  (0, _element.useEffect)(() => {
    if (isShownByDefault && isValueSet && !wasValueSet) {
      flagItemCustomization(label);
    }
  }, [isValueSet, wasValueSet, isShownByDefault, label]); // Note: `label` is used as a key when building menu item state in
  // `ToolsPanel`.

  const menuGroup = isShownByDefault ? 'default' : 'optional';
  const isMenuItemChecked = menuItems === null || menuItems === void 0 ? void 0 : (_menuItems$menuGroup = menuItems[menuGroup]) === null || _menuItems$menuGroup === void 0 ? void 0 : _menuItems$menuGroup[label];
  const wasMenuItemChecked = (0, _compose.usePrevious)(isMenuItemChecked); // Determine if the panel item's corresponding menu is being toggled and
  // trigger appropriate callback if it is.

  (0, _element.useEffect)(() => {
    if (isResetting || !hasMatchingPanel) {
      return;
    }

    if (isMenuItemChecked && !isValueSet && !wasMenuItemChecked) {
      onSelect === null || onSelect === void 0 ? void 0 : onSelect();
    }

    if (!isMenuItemChecked && wasMenuItemChecked) {
      onDeselect === null || onDeselect === void 0 ? void 0 : onDeselect();
    }
  }, [hasMatchingPanel, isMenuItemChecked, isResetting, isValueSet, wasMenuItemChecked]); // The item is shown if it is a default control regardless of whether it
  // has a value. Optional items are shown when they are checked or have
  // a value.

  const isShown = isShownByDefault ? (menuItems === null || menuItems === void 0 ? void 0 : (_menuItems$menuGroup2 = menuItems[menuGroup]) === null || _menuItems$menuGroup2 === void 0 ? void 0 : _menuItems$menuGroup2[label]) !== undefined : isMenuItemChecked;
  const cx = (0, _useCx.useCx)();
  const classes = (0, _element.useMemo)(() => {
    const placeholderStyle = shouldRenderPlaceholder && !isShown && styles.ToolsPanelItemPlaceholder;
    const firstItemStyle = firstDisplayedItem === label && __experimentalFirstVisibleItemClass;
    const lastItemStyle = lastDisplayedItem === label && __experimentalLastVisibleItemClass;
    return cx(styles.ToolsPanelItem, placeholderStyle, className, firstItemStyle, lastItemStyle);
  }, [isShown, shouldRenderPlaceholder, className, cx, firstDisplayedItem, lastDisplayedItem, __experimentalFirstVisibleItemClass, __experimentalLastVisibleItemClass]);
  return { ...otherProps,
    isShown,
    shouldRenderPlaceholder,
    className: classes
  };
}
//# sourceMappingURL=hook.js.map